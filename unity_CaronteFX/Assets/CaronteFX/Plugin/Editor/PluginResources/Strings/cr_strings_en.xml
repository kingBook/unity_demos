<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="Duplicate">Duplicate</string>
  <string name="DuplicateTooltip">Click here to duplicate the current focused node.</string> 
  <string name="Group">Group</string>
  <string name="GroupTooltip">This node is useful to organize the node hierarchy.</string>  
  <string name="Rigid">Rigid</string>
  <string name="RigidTooltip">Rigid Bodies. With this node you can create dynamic rigid bodies by dragging GameObjects to its Objects field. Rigid bodies are movable, not deformable, and they can interact with daemons and other body types (rigid, soft, cloth, rope, irresponsive, animated).</string>  
  <string name="Irresponsive">Irresponsive</string>
  <string name="IrresponsiveTooltip">Irresponsive Bodies. With this node you can create static or kinematic bodies by dragging GameObjects to its Objects field. Irresponsive bodies are non-deformable and do not react on other dynamic elements. To other bodies they appear as objects with a huge mass. A typical example for an irresponsive body is a ground plane. </string>  
  <string name="Animated">Animated</string>
  <string name="AnimatedTooltip">Animated Bodies. With this node you can create animated bodies (input fbx or carontefx animation into the simulation) by dragging GameObjects to its Objects field. The GameObjects must have an animator or cranimation component in their hierarchy.</string>
  <string name="Soft">Soft</string>
  <string name="SoftTooltip">Soft Bodies. With this node you can create soft bodies by dragging GameObjects to its Objects field. CaronteFX soft bodies can model plastic deformation. Soft bodies are movable, deformable, and they can interact with daemons and other body types (rigid, soft, cloth, rope, irresponsive, animated). You can decide whether the deformation is temporary or permanent.</string>
  <string name="Cloth">Cloth</string>
  <string name="ClothTooltip">Cloth Bodies. With this node you can create cloth bodies by dragging GameObjects to its Objects field. Cloth bodies are movable, deformable, and they can interact with daemons and other body types (rigid, soft, cloth, rope, irresponsive, animated).</string>  
  <string name="Rope">Rope</string>
  <string name="RopeTooltip">Rope Bodies. With this node you can create rope bodies by dragging GameObjects to its Objects field. Rope meshes must be spline meshes in order to work properly. Rope bodies are movable, deformable, and they can interact with daemons and other body types (rigid, soft, cloth, rope, irresponsive, animated).</string>  
  <string name="RigidGlue">Rigid Glue</string>
  <string name="RigidGlueTooltip">Rigid Glue. With this type of joint it is possible to quickly connect rigid bodies with varying orientation. “Rigid Glue” is perfectly suited for joining prefractured pieces.</string> 
  <string name="ByCloseAreaJoints">Close Area</string>
  <string name="ByCloseAreaJointsTooltip">Joints by close area. The type looks for the bodies’ polygons within a given area and connects them. Rigid, soft, cloth, rope, irresponsive and animated bodies are supported.</string> 
  <string name="ByCloseVerticesJoints">Close Vertices</string>
  <string name="ByCloseVerticesJointsTooltip">Joints by close vertices. This type looks for the bodies’ vertices within a given area and connects them. Rigid, soft, cloth, rope, irresponsive and animated bodies are supported.</string> 
  <string name="ByLeavesJoints">By Leaves</string>
  <string name="ByLeavesJointsTooltip">Joints by leaves. This mode is suitable for plants and similar setups. The leaves have to be very close to the tree’s branches.</string> 
  <string name="ByLocatorsJoints">By Locators</string>
  <string name="ByLocatorsJointsTooltip">Joints by locators. With this type you can connect bodies (rigid, soft, cloth, irresponsive) via helper Unity® GameObjects, e.g. cubes or spheres. This tool is perfectly suited if you want to create hinges.</string> 
  
  <string name="CreateRecreate">Create/Recreate</string>
  <string name="CreateRecreate*">Create/Recreate(*)</string>
  
  <string name="FracturerUniform">Uniform</string>
  <string name="FracturerUniformTooltip">Fracturer - Voronoi Uniform. This tool creates a random distribution of fragments.</string> 
  <string name="FracturerByGeometry">Geometry</string>
  <string name="FracturerByGeometryTooltip">Fracturer - Voronoi By Steering Geometry. An object is used to control zones of higher or lower fragment concentration, e.g. for defining impact areas.</string> 
  <string name="FracturerRadial">Radial</string>
  <string name="FracturerRadialTooltip">Fracturer - Voronoi Radial. With this tool it is possible to create radial patterns, suited to the creation of breaking glass or stucco. </string> 
  <string name="Welder">Welder</string>
  <string name="WelderTooltip">With this tool it is possible to create clusters of different objects with a single click. This process is non-destructive and the original objects will be kept.</string> 
  <string name="Selector">Selector</string>
  <string name="SelectorTooltip">This tool is used to select fragments with the help of a reference object and later you can for example weld them together.</string> 
  <string name="Tessellator">Tesselator</string>
  <string name="TessellatorTooltip">This tool allows you to subdivide an object. Specially soft bodies profit from high-resolution meshes, because this body type is deformed at the triangles’ vertices. Simulation results become better and better with a increasing number of triangles.</string> 
  <string name="HelperMesh">Helper Mesh</string>
  <string name="HelperMeshTooltip">Creates a helper mesh procedural geometry. It can be used as cropping object. e.g. for CaronteFX’s fracture tools, collision object, or as steering geometry for the “Geometry” fracture tool.</string> 
  <string name="MaterialSubstituter">Material Substituter</string>
  <string name="MaterialSubstituterTooltip">Material Substituter. This is tool allows you to replace a material in an entire hierarchy of Unity® GameObjects. You select the root object, and the tool will replace the original material (can be empty) with a new selected material (cannot be empty) across the whole selected hierarchy.</string>
  <string name="BalltreeGenerator">Balltree Generator</string>
  <string name="BalltreeGeneratorTooltip">Balltree Generator. This tool is used to create balltrees for the objects selected. Balltrees aproximate the geometry with sphere sets and can accelerate rigid body simulations.</string>

  <string name="MotorsLinear">Motors - Linear Velocity</string>
  <string name="MotorsLinearTooltip">Motors - Linear Velocity. With this node you can make bodies try to reach a certain target linear velocity.</string>
  <string name="MotorsAngular">Motors - Angular Velocity</string>
  <string name="MotorsAngularTooltip">Motors - Angular Velocity. With this node you can make bodies try to reach a certain target angular velocity.</string>
  <string name="ServosLinear">Servos - Linear Position</string>
  <string name="ServosLinearTooltip">Servos - Linear Position. With this node you can make bodies try to reach a certain target linear position.</string>
  <string name="ServosAngular">Servos - Angular Position</string>
  <string name="ServosAngularTooltip">Servos - Angular Position. With this node you can make bodies try to reach a certain target angular position.</string>
  
  <string name="DaemonGravity">Gravity</string>
  <string name="DaemonGravityTooltip">Gravity Daemon. In plain words, gravity makes things fall. Gravity is location-dependent and bodies experience different gravity on Earth, the Moon, or Mars. With CaronteFX it is possible to specify any direction.</string>
  <string name="DaemonExplosion">Explosion</string>
  <string name="DaemonExplosionTooltip">Explosion Daemon. Add an explosion to your scene, destroy objects, and cause some chaos. </string>
  <string name="DaemonWind">Wind</string>
  <string name="DaemonWindTooltip">Wind Daemon. Wind is an important natural phenomenon and CaronteFX’s daemon provides a very realistic wind model with many features.</string>
  <string name="DaemonJet">Jet</string>
  <string name="DaemonJetTooltip">Jet Daemon. Jet daemons can be attached to bodies at a specific location and add propulsion forces to them.</string>
  <string name="DaemonSpeedLimiter">Speed Limiter.</string>
  <string name="DaemonSpeedLimiterTooltip">Speed Limiter Daemon. This daemon will limit the maximun tangential or fall speed of any body in the scene.</string>
  <string name="DaemonAttractor">Attractor</string>
  <string name="DaemonAttractorTooltip">Attractor/Repulsor Daemon. This daemon must be attached to a body to work properly. The body will attract or repel other bodies in the scene. </string>
  <string name="DaemonAimedFall">Aimed Fall</string>
  <string name="DaemonAimedFallTooltip">Aimed Fall Daemon. This daemon requieres to specify the target position/orientation of the bodies as copy objects. The bodies will try to fall to the position/orientation of the copy objects.</string>
 
  <string name="TriggerByTime">By Time</string>
  <string name="TriggerByTimeTooltip">Trigger By Time. This node can unleash other action nodes. Works like a timer. Once the simulation time is reached the attached nodes will be unleashed.</string>
  <string name="TriggerByContact">By Contact</string>
  <string name="TriggerByContactTooltip">Trigger By Contact. This node can unleash other action nodes. Works by processing contacts between Bodies A and Bodies B. Once a contact is detected will unleash the connected nodes.</string>
  <string name="TriggerByDetector">By Detector</string>
  <string name="TriggerByDetectorTooltip">Trigger By Detector. This node can unleash other action nodes. Works by processing intersections between the detector bodies and normal bodies. Detector bodies must have disabled collision to work properly. Once an intersection is detected will unleash the connected nodes. </string>
  <string name="TriggerByExplosion">By Explosion</string>
  <string name="TriggerByExplosionTooltip">Trigger By Explosion. This node can unleash other action nodes. When any of the explosions reaches any of the specified bodies it will unleash the connected nodes.</string>
  <string name="TriggerByForce">By Pressure Force</string>
  <string name="TriggerByForceTooltip">Trigger By Pressure Force. This node can unleash other action nodes. When any of the specified bodies reaches a determined pressure force it will unleash the connected nodes.</string>
  
  <string name="ParameterModifier">Modifier</string>
  <string name="ParameterModifierTooltip">Parameter modifier. This action node works like a switch. You choose a property and define a time when it will be turned on, off, or when it will be flipped.</string>
  <string name="Substituter">Substituter</string>
  <string name="SubstituterTooltip">Substituter. The substituter node will substitute a group a bodies for other group of bodies during the simulation. The substituter will automatically handle the change of visibility and enable states of the originals and the substitutes at the moment of the substitution. The substitutes inherit position, velocity and shape (in the case of soft bodies and cloth objects) of the originals.</string>
  <string name="ContactEmitter">Contact Emitter.</string>
  <string name="ContactEmitterTooltip">Contact Emitter. This node will emmit contact events. Contact events contain information about position, velocities and momentum of the bodies involved. These events can be included to the baked files when the option is selected in the bake menu. The contact events are useful to synchronize the baked animations with sounds or particle effects.</string>  
  <string name="ScriptPlayer">Script player</string>
  <string name="ScriptPlayerTooltip">Script player. With this node you can implement and connect a CarSimulationScript (which inherits from ScriptableObjects) to the simulation and alter it in some way. For the moment only some actions are supported (like changing the targets of servos and motors). You can look at CarSimulationExampleScript for a basic use example.</string>

  <string name="Corpuscles">Corpuscles</string>
  <string name="CorpusclesTooltip">Add tooltip.</string>
  
  <string name="EfScope">Effect Scope</string>
  <string name="EfScopeTooltip">The scope is the set of Unity® GameObjects that are selectable in the CaronteFX nodes. A CaronteFx GameObject’s simulation nodes can be restricted to “Whole Scene”, “Fx GameObject Parent” or “Fx GameObject”. For more information on how to work with scope please read the “Understanding Scope” chapter of the manual.</string>  
  <string name="EfScopeWholeScene">Whole Scene</string>
  <string name="EfScopeFxGameObjectParent">FX GameObject Parent</string>
  <string name="EfScopeFxGameObject">FX GameObject</string>
  <string name="EfSelectScope">Select scope GameObjects</string>
  <string name="EfSelectScopeTooltip">Clicking this button all the Unity® GameObjects in the CaronteFX scope will be selected in the “Hierarchy” window. For more information on how to work with these options please read the “Understanding Scope” chapter of the manual.</string>
  <string name="EfGeneral">General</string>
  <string name="EfTotalSimulationTime">Total simulation time (s)</string>
  <string name="EfTotalSimulationTimeTooltip">How long do you want the simulation to last? Enter an appropriate number of seconds here.</string>
  <string name="EfTotalSimulationTimeReset">reset</string>
  <string name="EfTotalSimulationTimeResetTooltip">Apply CaronteFX’s default simulation time (10.0 s).</string>
  <string name="EfQuality">Quality</string>
  <string name="EfQualityTooltip">This parameter ranges from 1 to 100 and determines the simulation’s accuracy: \n• With higher settings, simulation times increase.\n• The default value is 50, but settings around 25 are sufficient in many cases.</string>
  <string name="EfAntiJittering">Anti-Jittering</string>
  <string name="EfAntiJitteringTooltip">With this parameter it is possible to gradually reduce trembling and jitter effects in a range from 0 to 100, where 100 completely removes the tremble.</string>
  <string name="EfFramesPerSecond">Frames per second (fps)</string>
  <string name="EfFramesPerSecondTooltip">Change the simulation’s fps rate.</string>
  <string name="EfAdvanced">Advanced</string>
  <string name="EfUserDefinedDeltaTime">User defined delta time</string>
  <string name="EfUserDefinedDeltaTimeTooltip">In simulations, time is not continuous, but subdivided into steps. The number of steps is responsible for the simulation’s accuracy and the more steps there are, the better the final result. As a side-effect, simulation time increases.\nCaronteFX determines the length of these steps, measured in seconds, automatically by default, and shorter values mean more steps. The associated parameter is the “Quality” slider. Alternatively you can also define the length of a time step manually by activating this option. Under “Delta time (secs)” you enter the desired value.</string>
  <string name="EfDeltaTime">Delta Time (s)</string>
  <string name="EfDeltaTimeTooltip">Enter the length of the custom time step in seconds. Smaller steps values will increase accuracy, but also simulation time. The value from “Last delta time” can be used as a reference.</string>
  <string name="EfLastDeltaTime">Last delta time</string>
  <string name="EfLastDeltaTimeTooltip">This is a read-only field and shows the length of the simulation’s last time step.</string>
  <string name="EfUserDefinedCharacteristicDistances">User defined characteristic distances</string>
  <string name="EfUserDefinedCharacteristicDistancesTooltip">This feature helps to maintains the behaviour of the scene’s elements when you perform simulations in several parts. If you decide to add completely new elements to an existing scene you have to preserve the Thickness and Length parameter values to keep simulation outcomes consistent.</string>
  <string name="EfThickness">Thickness</string>
  <string name="EfThicknessTooltip">This parameter is related to the scene’s objects thickness.</string>
  <string name="EfLastThickness">Last thickness</string>
  <string name="EfLastThicknessTooltip">This is a read-only field. Here you can see the values the solver used during the last simulation.</string>
  <string name="EfLength">Length</string>
  <string name="EfLengthTooltip">This parameter describes the scene’s characteristic object length.</string>
  <string name="EfLastLength">Last length</string>
  <string name="EfLastLengthTooltip">This is a read-only field. Here you can see the values the solver used during the last simulation.</string>
    
  <string name="EnabledToggle">Enabled</string>
  <string name="EnabledToggleTooltip">Enable or disable the selected node. The property is applied when the simulation starts and is inherited by all the children nodes.</string>
  <string name="VisibleToggle">Visible</string>
  <string name="VisibleToggleTooltip">Show or hide the selected node in the viewport. The property is applied when the simulation starts and is inherited by all the children nodes.</string>
  <string name="OverridenToOff">(Overidden to off)</string>  

  <string name="BdObjectsBodyField">Objects</string>
  <string name="BdObjectsBodyFieldTooltip">If you drag and drop here GameObjects you will create bodies in the simulation. You can also create bodies by name wildcard (CaronteFX will search in the scene for name matches).\n\nYou can left click on the field rectangle to display the Objects Editor Window or right click on it to display the actions context menu.</string>
  <string name="BdCollideToggle">Collide</string>
  <string name="BdCollideToggleTooltip">When disabled the body will not be able to collide with other bodies anymore.</string>
  <string name="BdAutocollide">Auto collide</string>
  <string name="BdAutocollideTooltip">When active, CaronteFX will calculate collisions between the object’s vertices and polygons (also known as self-collision). With complex geometry, simulation time will increase noticeably.</string>
  <string name="BdDisableCollisionsAtJoints">Disable collisions at joints</string>
  <string name="BdDisableCollisionsAtJointsTooltip">When active, the cloth will disable its collision near the area of the joints pivots if it's taking part in any joint.</string>
  <string name="BdSetMassByOption">Set mass by</string>
  <string name="BdSetMassByOptionTooltip">If the node is composed of multiple rigid bodies the entered value will be applied to every body. Choose density when you want all the bodies to share the same physical material.</string>
  <string name="BdMass">Mass per object</string>
  <string name="BdMassTooltip">Here you enter a specific mass in kg. If the body is composed of multiple rigid bodies the entered value will be applied to every body. If the bodies have different volumes, density will be varying.</string>
  <string name="BdDensity">Density</string>
  <string name="BdDensityTooltip">This parameter is measured in kg/m3. If the node is composed of multiple rigid bodies the entered value will be applied to every body. If the bodies have different volumes, mass will be varying.</string>
  <string name="BdRestitution">Restitution</string>
  <string name="BdRestitutionTooltip">When bodies collide they bounce off. The resulting effective bounciness is calculated from the “Restitution” values of all colliding bodies. This parameter ranges from 0 to 1.</string>
  <string name="BdKineticFriction">Kinetic friction</string>
  <string name="BdKineticFrictionTooltip">In the real world, objects have more or less uneven surfaces and this circumstance causes a loss of motion energy. The resulting effective kinetic friction is calculated from the “Friction kinetic” values of all interacting bodies. This parameter ranges from 0 to 1.</string>
  <string name="BdStaticFriction">Static friction</string>
  <string name="BdStaticFrictionTooltip">This property can be seen a measure for a body’s ability to start sliding. The resulting effective static friction is calculated from the “Friction static” values of all interacting bodies. This parameter ranges from 0 to 1. With “From kinetic” enabled, the value is taken from the “Kinetic friction” parameter.</string>
  <string name="BdFromKinetic">From kinetic</string>
  <string name="BdExternalDamping">External damping</string>
  <string name="BdExternalDampingTooltip">This parameter decreases a rigid body’s velocity (linear and angular), and very high settings can cause a body to stop completely. You can use any positive value.</string>
  <string name="BdInitialLinearVelocty">Initial linear velocity</string>
  <string name="BdInitialLinearVeloctyTooltip">Here a start velocity is defined. The resulting velocity is calculated from the three axes; they also determine the object’s motion direction. All positive and negative values, including 0, are allowed.</string>
  <string name="BdInitialLinearAngularVelocity">Initial angular velocity</string>
  <string name="BdInitialLinearAngularVelocityTooltip">The three values represent an object’s rotation axes. Each value specifies how many degrees the object will cover per second. As a result the body will be spinning around its centre of gravity. All positive and negative values, including 0, are allowed.</string>
  <string name="BdExplosionOpacity">Explosion opacity</string>
  <string name="BdExplosionOpacityTooltip">Objects can attenuate or damp the effect of an explosion. Other bodies behind such a “blocker” are more or less affected by the explosion. This parameter ranges from 0 to 1, and specifies how strong this attenuation will be. With 1, the object will block the explosion completely.</string>
  <string name="BdExplosionResponsiveness">Explosion responsiveness</string>
  <string name="BdExplosionResponsivenessTooltip">Here you can adjust directly how strong a body will respond to an explosion. The parameter rangesfrom 0 to 1. With 1, the object will be fully affected by the explosion without any attenuation.</string> 
  <string name="BdInternalDamping">Internal damping</string>
  <string name="BdInternalDampingTooltip">A soft body or rope always has a certain amount of internal motion (“wobbling”). With “Internal damping” and “Restitution” it is possible to control this effect. “Internal damping” accepts any positive value. With high settings, the body will stop wobbling quickly, and it will also experience smaller bounces.</string>

  <string name="AnAnimationType">Animation type</string>
  <string name="AnAnimationTypeTooltip">Input animations can be Unity animation clips or other prebaked CaronteFX animations. When Animation clip is selected, there must be an Animator component in the hierarchy of the Objects. When CaronteFX clip is selected there must be a CRAnimation in the hierarchy of the Objects. </string>
  <string name="AnAnimationClipType">Animation clip</string>
  <string name="AnCaronteFXClipType">CaronteFX clip</string>
  <string name="AnOverrideAnimationControllerToggle">Override animation controller.</string>
  <string name="AnOverrideAnimationControllerToggleTooltip">If disabled the animated objects will use the current animation controller defined in their animator components.</string>
  <string name="AnAnimationClip">Animation clip</string>
  <string name="AnAnimationClipTooltip">The animation that will be played when the override animation controller option is active.</string>
  <string name="AnTimeStart">Time start</string>
  <string name="AnTimeStartTooltip">The animation will start at the given simulation time measured in seconds.</string>
  <string name="AnTimeLength">Time length</string>
  <string name="AnTimeLengthTooltip">This is the animation's duration. After this period of time the body will remain motionless at it last position. By default the animation will play its whole duration. “Time length” is given in seconds.</string>
  <string name="AnResetTimeLength">reset</string>

  <string name="SbResolution">Resolution</string>
  <string name="SbResolutionTooltip">A soft body is subdivided into flexible elements and the number of elements defines the simulation’s accuracy. With higher settings you are able to achieve a higher level of detail, but at the cost of longer simulation times. The object’s maximum “Resolution” depends on its number of triangles and for higher accuracy more (= smaller) triangles are needed.</string>
  <string name="SbRelativeLengthStiffness">Relative length stiffness</string>
  <string name="SbRelativeLengthStiffnessTooltip">The higher the value, the more rigid the object will finally appear, because it will be more resistant against changes along its longitudinal axes (width, length, height). This parameter accepts any positive value. With 1, for example, a soft body will nearly maintain its shape when resting on a horizontal plane. In this case, the body is able to resist its own weight without being deformed.</string>
  <string name="SbRelativeVolumeStiffness">Relative volume stiffness</string>
  <string name="SbRelativeVolumeStiffnessTooltip">The higher the value, the more rigid the object will finally appear, because it will be more resistant against changes of its original volume. This parameter accepts any positive value. With 1, for example, a soft body will nearly maintain its shape when resting on a horizontal plane. In this case, the body is able to resist its own weight without being deformed.</string>
  <string name="SbPlasticity">Plasticity</string>
  <string name="SbPlasticityTooltip">When enabled, parts of the object will remain deformed. The final amount of permanent deformation depends on the associated parameters.</string>
  <string name="SbPlasticityThreshold">Threshold</string>
  <string name="SbPlasticityThresholdTooltip">As long as this limit is not reached the deformation will still be able to recover. If the deformation is stronger it will remain permanently. The parameter ranges between 0 and 1. A value of 0.5 means that the change of volume in any direction has to be at least 50% of the object’s original size to produce permanent deformation.</string>
  <string name="SbPlasticityAcquired">Acquired</string>
  <string name="SbPlasticityAcquiredTooltip">This parameter represents the percentage of deformation that will remain permanent. With 0.0, the object will recover completely, with 1.0 the entire deformation will be kept.</string>
  <string name="SbPlasticityCompressionLimit">Compression limit</string>
  <string name="SbPlasticityCompressionLimitTooltip">With this parameter it is possible to prevent a soft body from becoming very flat. The parameter ranges between 0 and 1. With 0.5, for example, deformations will be permanent when the body’s compression in any direction is 50% of its original size. Deformations beyond this limit will be able to recover.</string>
  <string name="SbPlasticityExpansionLimit">Expansion limit</string>
  <string name="SbPlasticityExpansionLimitTooltip">The mode of operation is very similar to “Compression limit”, but here the soft body is prevented from becoming too thick. The parameter accepts any positive value. With 2.0, for example, deformations will be permanent when the body’s expansion in any direction is 50% of its original size. Deformations beyond this limit will be able to recover.</string>

  <string name="ClCollisionRadius">Collision radius</string>
  <string name="ClCollisionRadiusTooltip">Cloth bodies are represented by a set of spheres distributed along the mesh surface, this parameter determines the radius of those spheres.</string>
  <string name="ClSafeModeIntegration">Safe mode integration</string>
  <string name="ClSafeModeIntegrationTooltip">When active, cloth simulation will resist better impossible physical situations (like collisions with the armpits of an animated body), at a cost of speed and contact accuracy.</string>
  <string name="ClUseColliderUVsAsRegions">Use collider UVs as regions</string>
  <string name="ClUseColliderUVsAsRegionsTooltip">When enable, the cloth collider mesh UVs will be used to determine different regions in the cloth body. This is useful to make cloth folds to collide properly.</string> 
  <string name="ClBendStiffness">Bend stiffness</string>
  <string name="ClBendStiffnessTooltip">Determines how the cloth bends. A higher value will reduce the cloth bending.</string>
  <string name="ClStretchStiffness">Stretch stiffness</string>
  <string name="ClStretchStiffnessTooltip">Determines how the cloth strecths. A higher value will reduce the cloth streching.</string>
  <string name="ClBendDamping">Bend damping</string>
  <string name="ClBendDampingTooltip">A cloth body always has a certain amount of internal motion (“wobbling”). This can help to control it in the bend links.</string>
  <string name="ClStretchDamping">Stretch damping</string>
  <string name="ClStretchDampingTooltip">A cloth body always has a certain amount of internal motion (“wobbling”). This can help to control it in the stretch links.</string>

  <string name="RpSidesNumber">Sides number</string>
  <string name="RpSidesNumberTooltip">When you click on simulate a new rope mesh will be created with the number of sides set in this field. The original mesh in not used for rope simulation.</string> 
  <string name="RpStretchStiffness">Stretch stiffness</string>
  <string name="RpStretchStiffnessTooltip">Determines how the rope stretches. A higher value will reduce the rope stretching.</string>
  <string name="RpBendStiffness">Bend stiffness</string>
  <string name="RpBendStiffnessTooltip">Determines how the rope bends. A higher value will reduce the rope bending.</string>
  <string name="RpTorsionStiffness">Torsion stiffness</string>
  <string name="RpTorsionStiffnessTooltip">Determines how the rope twists. A higher value will reduce the rope twisting.</string>
  
  <string name="JgObjectsA">ObjectsA</string>
  <string name="JgObjectsB">ObjectsB</string>  
  <string name="JgObjectsTooltip">MultiJoint Objects. Here you drag and drop GameObjects to create joints between the bodies indicated in the field ObjectsA and the bodies indicated in field ObjectsB. Alternatively you can create joints by selecting body nodes or by selecting bodies by wildcard. If you use joints by locator you can leave field ObjectsB empty to create joints to the world.\n\nYou can left click on the field rectangle to display the Objects Editor Window or right click on it to display the actions context menu.</string>
  <string name="JgLocatorsC">Locators</string>
  <string name="JgLocatorsCTooltip">Locators determine where the joints will be created. You can drag here GameObjects. Under “Creation Mode” you find three methods to connect the objects.</string> 
  <string name="JgLeaves">Leaves</string>
  <string name="JgLeavesTooltip">The leaf objects have to be added here. Leaves have to be very close to the tree's branches.</string>
  <string name="JgTrunks">Trunks</string>
  <string name="JgTrunksTooltip">The trunk objects have to be added here.</string>
  <string name="JgCreationTime">Creation time (s)</string>
  <string name="JgCreationTimeTooltip">If the creation time is not 0 the joints will be created during simulation, when the specified simulation time is reached. Time is measured in seconds.</string>
  <string name="JgDistanceSearch">Distance search (m)</string>
  <string name="JgDistanceSearchTooltip">With this parameter you can define the distance at which CaronteFX should look for objects to connect. By increasing this value you can look for object pairs which are further away.</string>
  <string name="JgMatchingDistanceSearch">Distance search (m)</string>
  <string name="JgMatchingDistanceSearchTooltip">With this parameter you can define the distance at which CaronteFX should look for objects vertices to connect. By increasing this value you can look for object vertices pairs which are further away.</string>
  <string name="JgAreaMin">Area min.</string>
  <string name="JgAreaMinTooltip">To establish joints, the contact area between the faces of two bodies must be greater than this value. It is safe to leave the default value in most cases. The value is measured in metres.</string>
  <string name="JgAngleMax">Angle max.</string>
  <string name="JgAngleMaxTooltip">Joints will only be created when the angles between bodies' faces are smaller than this value. The value is given in degrees.</string>
  <string name="JgNumberMaxPerPair">Number max. per pair</string>
  <string name="JgNumberMaxPerPairTooltip">With this parameter you can limit the number of connections per pair of bodies. CaronteFX selects the most significant joints. Higher settings create more connections.</string>
  <string name="JgLimitNumberOfProcessedJoints">Limit number of processed joints</string>
  <string name="JgLimitNumberOfProcessedJointsTooltip">This option restricts the number of joints that are actually processed during simulation. The number of joints does not change, but CaronteFX will choose the ones which are best suited.</string>
  <string name="JgMaxProcessedJointsPerPair">Max processed joints per pair</string>
  <string name="JgMaxProcessedJointsPerPairTooltip">By default, all joints are processed at the same time and this can be a time-consuming task. With this parameter it is possible to “group” the joints to accelerate the simulation. An example: a bone linked to its surrounding flesh. The bone’s vertices are used to create the joints, let’s say 1,000 and “Max processed joints per pair” is set to 50. During calculation all of them will be processed, but only 50 at once.</string>
  <string name="JgDisableCollisionByPairs">Disable collisions by pairs</string>
  <string name="JgDisableCollisionByPairsTooltip">When enabled, CaronteFX stops processing collisions between all body pairs connected by joints. This results in shorter simulation times.</string>
  <string name="JgDisableAllCollisionBetweenAB">Disable all collisions A-B</string>
  <string name="JgDisableAllCollisionBetweenABTooltip">The difference to “Disable collisions by pairs” is that bodies from “ObjectsA | B” do not necessarily have to be connected by joints, all collisions between the bodies of A and B will be disabled. An example is a pre-fractured object where you do not need collision between the fragments until it begins to break apart.</string>
  <string name="JgMaxForceNm2">Max force (N/m2)</string>
  <string name="JgMaxForceNm2Tooltip">Define the force by area unit which is needed to separate the objects. When the acting force is smaller than “Max force (N/m2)” the joint remains intact and the objects are pulled back. It requires some testing and experience to find working settings.</string>
  <string name="JgMaxForceN">Max force (N)</string>
  <string name="JgMaxForceNTooltip">Define the force which is needed to separate the objects. When the acting force is smaller than “Max force (N)” the joint remains intact and the objects are pulled back. It requires some testing and experience to find working settings.</string>
  <string name="JgMaximumForce">Maximum</string>
  <string name="JgMaximumForceTooltip">With “Maximum” enabled, objects joined cannot become separated, no matter what happens.</string>
  <string name="JgMaxForceRand">Max force rand.</string>
  <string name="JgMaxForceRandTooltip">The actual value will be between 0 and the Max force multiplied by the rand value. The total force is calculated this way: Total force = Max force + Max force rand.</string> 
  <string name="JgForceRange">Force range (m)</string>
  <string name="JgForceRangeTooltip">The “bandwidth” in which the force acts on the joints, given in metres.</string>
  <string name="JgForceProfile">Force profile</string>
  <string name="JgForceProfileTooltip">You can draw a curve to determine the force at different distance points. The curve is shown normalized, but depends on the force rage. This way it is possible to define a decreasing range of forces with growing distance, force peaks, etc.</string>
  <string name="JgBreakIfDistanceExceeded">Break if distance exceeded</string>
  <string name="JgBreakIfDistanceExceededTooltip">With the associated “Break distance (m)” you can define a distance at which a joint will break.</string>
  <string name="JgBreakDistance">Break distance (m)</string>
  <string name="JgBreakDistanceTooltip">If the given distance between two joints is exceeded, the connection is broken. The unit is metres.</string>
  <string name="JgBreakDistanceRand">Break distance rand.</string>
  <string name="JgBreakDistanceRandTooltip">The actual value will be between 0 and the Break distance multiplied by the rand value. This value is given in metres and the total distance is calculated this way: Total distance = Break distance + Break distance random</string>
  <string name="JgBreakAllInPairIfFewUnbroken">Break all in pair if few unbroken</string>
  <string name="JgBreakAllInPairIfFewUnbrokenTooltip">It is advised to enable this option if you can see constraint effects between bodies which should be completely separated. An example: Some bricks of a wall stick together, because not all joints are broken. Those hinged bricks can be separated with this option. The broken joints limit is defined under “Unbroken number to break all”.</string>
  <string name="JgUnbrokenNumberToBreakAll">Unbroken number to break all</string>
  <string name="JgUnbrokenNumberToBreakAllTooltip">If the number of broken joints is reached by a particular pair of linked bodies, all remaining connections between them will be broken.</string>
  <string name="JgBreakIfHinge">Break if hinge</string>
  <string name="JgBreakIfHingeTooltip">There are cases where objects are loosely connected and the joints behave like hinges. Enable this feature to avoid such a behaviour.</string>
  <string name="JgEnableCollisionsIfBreak">Enable collisions if break</string>
  <string name="JgEnableCollisionsIfBreakTooltip">When active, objects with broken joints will not interpenetrate. The way, how the collision is handled also depends on “Disable collision by pairs” and “Disable all collisions A-B”.</string>
  <string name="JgPlasticity">Plasticity</string>
  <string name="JgPlasticityTooltip">With “Plasticity” you can make fragments stick together as if they were connected with a kind of underlying tissue or grid, while other parts can still leave the assembly.</string>
  <string name="JgPlasticityDistance">Plasticity distance (m)</string>
  <string name="JgPlasticityDistanceTooltip">When the distance between two joints exceeds this value the connection between joints becomes irreversible it behaves like an overstretched rubber band. This value is given in metres.</string>
  <string name="JgPlasticityDistanceRand">Plasticity distance rand.</string>
  <string name="JgPlasticityDistanceRandTooltip">The actual value will be between 0 and the plasticity distance multiplied by the rand value. This value is given in metres and the total distance is calculated this way: Total distance = Plasticity distance + Plasticity distance random.</string>
  <string name="JgPlasticityAcquired">Plasticity acquired</string>
  <string name="JgPlasticityAcquiredTooltip">The parameter’s range goes from 0.0 to 1.0. A setting of 0.5 will keep approximately 50% of a joint’s deformation as permanent. The other half is able to relax and turn back to its initial state.</string>
  <string name="JgLocatorsCreationMode">Creation mode</string>
  <string name="JgLocatorsCreationModeTooltip">These options determine how the objects are linked together: \n• “At locators positions”. Here you create objects and place them between the objects meant to be linked. The joints will be created at the pivot points of the helper nodes. All locator nodes have tobe added to “Locators”.\n• “At locators vertices”. With this mode, the locator’s vertex positions are used to connect the two nearest objects from “Leaves” and “Trunks”. Objects will be linked, even if they are far away from the joint. \n• “At locators bbox centres”. This mode allows you to use any objects shape as a locator. The geometrical centre of a bounding box around the selected locator(s) is used to create the joints.</string>
  <string name="JgLocatorsModePositions">At locators positions</string>
  <string name="JgLocatorsModeVertexes">At locators vertexes</string>
  <string name="JgLocatorsModeBBoxCenters">At locators box centers</string>
  <string name="JgDamping">Damping</string>
  <string name="JgDampingTooltip">This parameter only applys to rigidbody - rigidbody joints. Damping force applied to each pair of rigid bodies joined.</string>
  
  <string name="ToolsObjects">Objects</string>
  <string name="ToolsObjectsTooltip">Here you drag and drop GameObjects that will be the input geometries of the fracture node.\n\nYou can also set the input by name wildcard (CaronteFX will search in the scene for name matches). You can left click on the field rectangle to display the Objects Editor Window or right click on it to display the actions context menu.</string>
  
  <string name="FrGlobalPattern">Global pattern</string>
  <string name="FrGlobalPatternTooltip">This option is only relevant in conjunction with multiple objects. When active\n• all objects under “Objects” are treated as one coherent object\n• you will see propagating cracks\n• the total number of fragments corresponds with “Rough number of pieces”. Otherwise every object is fractured individually, and the total amount of fragments isRough number of pieces * number of Unity® GameObjects </string>
  <string name="FrRoughNumberOfPieces">Rough number of pieces</string>
  <string name="FrRoughNumberOfPiecesTooltip">Here you can specify how many fragments you want to create. In some cases the resulting number of fragments slightly differs from the input value. You can enter any positive integer greater than 0.</string>
  <string name="FrSeed">Seed</string>
  <string name="FrSeedTooltip">If you want to achieve a different distribution of fragments change this value – you can enter any positive integer.</string>
  
  <string name="FrInteriorFacesMaterial">Interior faces material</string>
  <string name="FrInteriorFacesMaterialTooltip">The specified material will applied to the newly created faces of the fractures.</string>
  <string name="FrInteriorFacesSmoothingAngle">Interior faces smoothing angle</string>
  <string name="FrInteriorFacesSmoothingAngleTooltip">This parameter indicates how internal faces will be smoothed based on the angle between them.</string>
  <string name="FrInteriorFacesTiling">Tiling</string>
  <string name="FrInteriorFacesTilingTooltip">This parameter indicate the UVs tiling of the internal faces.</string>
  <string name="FrInteriorFacesOffset">Offset</string>
  <string name="FrInteriorFacesOffsetTooltip">This parameter indicates the UVs offset of the internal faces.</string>
  <string name="FrGenerateNewSubmeshForInteriorFaces">Interior faces in new submesh</string>
  <string name="FrGenerateNewSubmeshForInteriorFacesTooltip">When active interior faces will be generated in a new submesh. If not active interior faces will be generated in the first existing submesh.</string>
  <string name="FrModifyInteriorFacesUVs">Modify interior faces UVs...</string>
  <string name="FrModifyInteriorFacesUVsTooltip">From this menu you can modify the uv layout of the new generated interior faces.</string>
  
  
  <string name="FrExtrusionEffect">Extrussion effect</string>
  <string name="FrExtrusionEffectTooltip">When enabled the result is an effect that is similar to the look of a jigsaw puzzle:\n• The pieces are cut out like cookies and are not arranged in layers or stacks.\n• “Extrusion effect” is useful if you want to punch a hole into a wall or create the effect of a thin breaking pane of glass.</string>
  <string name="FrCoordinate">Coordinate</string>
  <string name="FrCoordinateTooltip">When enabled CaronteFX will restructure the fractured meshes by adding new triangles with shared vertices. This way, if you create deformable bodies from the fractured objects they can be deformed without holes. Check manual for more detailed information.</string>
  <string name="FrAutoHideOriginalObjects">Auto hide original objects</string>
  <string name="FrAutoHideOriginalObjectsTooltip">The fracture tools are non-destructive and the original objects will be kept in the scene. When this option is enabled, the original object is hidden.</string>

  <string name="FrSteeringGeometry">Steering geometry</string>
  <string name="FrSteeringGeometryTooltip">The chosen object is used to indicate the zone with the highest concentration of pieces.</string>
  <string name="FrSteeringGeometries">Steering geometries</string>
  <string name="FrSteeringGeometriesTooltip">Selected objects must contain a geometry. The chosen objects are used to indicate the zone with the highest concentration of pieces.</string>
  <string name="FrSteeringResolution">Steering resolution</string>
  <string name="FrSteeringResolutionTooltip">The steering geometries are rasterized for the fragmentation process and this parameter defines the quality of that process. Higher values will represent the shape of the steering geometries much better.</string>
  <string name="FrFocusMode">Highest concentration</string>
  <string name="FrFocusModeTooltip">According to the selected option the highest concentration of fragments is created “Inside”, “Outside” , “Along the boundary” or “Out of the boundary” of the steering object.</string>
  <string name="FrDensityRate">Lowest/highest concentration rate</string>
  <string name="FrDensityRateTooltip">This value determines the ratio of the number of fragments in areas with higher and lower fragment concentration. With smaller values the transition between these areas becomes sharper.</string>
  <string name="FrTransitionLength">Transition length</string>
  <string name="FrTransitionLengthTooltip">This parameter affects the transition between zones of higher and lower fragment density.</string>

  <string name="FrReferenceSystem">Reference system</string>
  <string name="FrReferenceSystemTooltip">The fragmentation pattern is created at the position of a helper object (“Reference system”) and projected on a 2D plane along the source’s X, Y, or Z axis.</string>
  <string name="FrFrontDirection">Front direction</string>
  <string name="FrFrontDirectionTooltip">The pattern’s orientation is specified with the “Front direction” options: X, Y, and Z.</string>
  <string name="FrRaysNumber">Rays number</string>
  <string name="FrRaysNumberTooltip">Here you can determine how many rays you want to create.</string>
  <string name="FrRaysAngleRandomness">Rays angle randomness</string>
  <string name="FrRaysAngleRandomnessTooltip">By default, all rays are created with the same angle between them. If you want to displace the rays enter a number between 0.0 and 1.0 (highest randomness).</string>
  <string name="FrRingIntRadius">Annulus internal radius</string>
  <string name="FrRingIntRadiusTooltip">This is the inner distance of the annulus from the radial pattern’s centre – the centre is specified through the object under “Reference system”. The unit is metres.</string>
  <string name="FrRingIntTransitionLength">Internal transition length</string>
  <string name="FrRingIntTransitionLengthTooltip">Here you determine how far from the “Annulus internal radius” additional rings are created. The unit is metres.</string>
  <string name="FrRingIntTransitionDecay">Internal transition decay</string>
  <string name="FrRintIntTransitionDecayTooltip">Here you determine how fast the rings outside the annulus (measured from the inner boundary of the annulus) are separated. The value ranges between 0 (no decay) and 1 (maximum decay).</string>
  <string name="FrRingExtRadius">Annulus external radius</string>
  <string name="FrRingExtRadiusTooltip">This is the outer distance of the annulus from the radial pattern’s centre – the centre is specified through the object under “Source”.</string>
  <string name="FrRingExtTransitionLength">External transition length</string>
  <string name="FrRingExtTransitionLengthTooltip">Here you determine how far from the “Annulus external radius” additional rings are created. The unit is metres.</string>
  <string name="FrRingExtTransitionDecay">External transition decay</string>
  <string name="FrRintExtTransitionDecayTooltip">Here you determine how fast the rings outside the annulus (measured from the outer boundary of the annulus) are separated. The value ranges between 0 (no decay) and 1 (maximum decay).</string>
  
  <string name="FrRingsNumberInsideAnnulus">Rings number inside annulus</string>
  <string name="FrRingsNumberInsideAnnulusTooltip">Enter, how many rings you want to create inside the annulus – the area between “Annulus internal radius” and Annulus external radius”.</string>
  <string name="FrRingsRadiusRandomness">Rings radius randomness</string>
  <string name="FrRingsRadiusRandomnessTooltip">By default, all rings inside the annulus have exactly the same distance from each other; in transition zones, the rings obey the decay parameters – with a value of 0 (= no decay), the rings will be equispaced as well. To avoid this, enter a degree of randomness between 0.0 and 1.0 (maximum randomness).</string>
  <string name="FrCreateCentralPiece">Create central piece</string>
  <string name="FrCreateCentralPieceTooltip">When enabled a fragment is created directly at the centre of the radial pattern.</string>

  <string name="FrNoise">Noise</string>
  <string name="FrNoiseTooltip">Add a small amount of random displacement to create a more random look. Values range between 0.0 and 1.0 (maximum noise).</string>
  <string name="FrTwist">Twist</string>
  <string name="FrTwistTooltip">You can also displace the radial pattern to get a look similar to a spiral or the arrangement of sunflower seeds. Valid values are between -1.0 (maximum twist counterclockwise) and 1.0 (maximum twist clockwise). With 0, no twist will be applied.</string>
   
  <string name="FrRestrictFractureZone">Restrict fracture zone</string>
  <string name="FrRestrictFractureZoneTooltip">Restrict fracture is used to create custom clusters of fragments or increase the number of fragments in user-defined areas with the help of a reference object.</string>
  <string name="FrRestrictionGeometry">Restriction geometry</string>
  <string name="FrRestrictionGeometryTooltip">Add to this field a scene GameObject (must content a mesh) positioned where you want to apply the restriction.</string>
  <string name="FrRestrictionGeometries">Restriction geometries</string>
  <string name="FrRestrictionGeometriesTooltip">Add to this field scene GameObjects (must content a mesh) positioned where you want to apply the restriction.</string>
  <string name="FrFractureZone">Fracture zone</string>
  <string name="FrFractureZoneTooltip">Here you specify how the restriction process will be applied based on the reference object from "Restriction geometry”: strictly inside or outside the steering object, or including nodes which are inside the steering object’s bounding box.</string>
  <string name="FrUnfracturedMesh">Unfractured mesh</string>
  <string name="FrUnfracturedMeshTooltip">Here you specity if the non-restricion fragments will be reconnected to a single piece or left individual.</string>
  <string name="FrStrictlyInside">STRICTLY INSIDE</string>
  <string name="FrInsidePlusBoundary">INSIDE + BOUNDARY</string>
  <string name="FrStrictlyOutside">STRICTLY INSIDE</string>
  <string name="FrOutsidePlusBoundary">OUTSIDE + BOUNDARY</string>
  <string name="FrTabParameters">Parameters</string>
  <string name="FrTabStats">Stats</string>
  <string name="FrUniteDisconnectedParts">UNITE DISCONNECTED PARTS</string>
  <string name="FrSeparateDisconnectedParts">SEPARATE DISCONNECTED PARTS</string>
  
  <string name="FrInteriorFacesNoise">Interior faces noise</string>
  <string name="FrInteriorFacesNoiseTooltip">Add tooltip</string>
  <string name="FrNoiseResolutionRate">Noise resolution rate</string>
  <string name="FrNoiseResolutionRateTooltip">Add tooltip</string>
  <string name="FrNoiseReliefAmplitureRate">Noise relief amplitude rate</string>
  <string name="FrNoiseReliefAmplitureRateTooltip">Add tooltip</string>
  <string name="FrNoiseReliefSerrationRate">Noise relief serration rate</string>
  <string name="FrNoiseReliefSerrationRateTooltip">Add tooltip</string>
  <string name="FrNoiseSeed">Noise seed</string>
  <string name="FrNoiseSeedTooltip">Add tooltip</string>
  <string name="FrDoNoiseExtrusionEffect">Extrusion effect</string>
  <string name="FrDoNoiseExtrusionEffectTooltip">Add tooltip</string>
	
  <string name="FrOutputSection">Output</string>	
  <string name="FrSelectPieces">Select pieces</string>
  <string name="FrSelectPiecesTooltip">This button makes the freshly created output the current object selection.</string>
  <string name="FrPushRate">Push rate</string>
  <string name="FrPushRateTooltip">By dragging the slider you can separate the pieces. The distance ranges between 0 (touching) and 1 (maximum separation). If you want to create bigger gaps between the objects please use “Push Multiplier”</string>
  <string name="FrPushMultiplier">Push multiplier</string>
  <string name="FrPushMultiplierTooltip">Create bigger gaps between the fragments with this slider (please see “Push Rate”).</string>

  <string name="WdSelectWeldedObject">Select welded objects</string>
  <string name="WdSelectWeldedObjectTooltip">By clicking this button you will select the current welded object.</string>
 
  <string name="BtCreationMode">Creation Mode</string>
  <string name="BtCreationModeTooltip">With this parameter you indicate if the balltree will be constructed from the render mesh of the gameobject or the collider mesh if it has a Caronte_FX_Body component attached.</string>
  <string name="BtCreationModeUseRenderers">USE MESH RENDERERS</string>
  <string name="BtCreationModeUseColliders">USER MESH COLLIDERS</string>
  <string name="BtSpherePopulation">Sphere population</string>
  <string name="BtSpherePopulationTooltip">With this parameter you can control the number of spheres that will be used in the balltree construction.</string>
  <string name="BtArrangementQuality">Arrangement quality</string>
  <string name="BtArrangementQualityTooltip">With this parameter you can control how well the spheres will be placed inside the original geometry.</string>
  <string name="BtHoleCovering">Hole covering</string>
  <string name="BtHoleCoveringTooltip">Increase this parameter if the input meshes are not closed.</string>
 
  </resources>